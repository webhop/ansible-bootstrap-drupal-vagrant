---
- name: Install sendmail-bin package
  apt:
    name: "{{ item }}"
  with_items:
    - sendmail-bin
    - libmysqlclient-dev

- name: Install pip modules
  pip:
    name: "{{ item }}"
  with_items:
    - MySQL-python
    - boto
    - boto3
    - botocore

- name: Create any additional non-drupal databases
  mysql_db:
    db: "{{ item }}"
    state: present
  with_items: additional_dbs_to_create

- name: Create a MySQL database for Drupal.
  mysql_db:
    db: "{{ drupal_mysql_database }}"
    state: present

- name: Create a MySQL user for Drupal.
  mysql_user:
    name: "{{ drupal_mysql_user }}"
    host: "{{ item }}"
    priv: "{{ drupal_mysql_database }}.*:ALL"
    password: "{{ drupal_mysql_password }}"
  with_items:
    - 127.0.0.1
    - ::1
    - localhost
  when: drupal_mysql_user != 'root'

- name: Check for existence of Drupal database
  command: '/usr/bin/mysql -N -s -u {{ drupal_mysql_user }} -p{{ drupal_mysql_password }} -e "SELECT COUNT(1) FROM information_schema.tables WHERE table_schema=''drupal'';"'
  register: drupal_table_count


# Due to this bug https://github.com/ansible/ansible/issues/9526 we have to split out the write to the shared mount
# when running on a windows host.

# Ensure the settings file is deleted if it exists
- name: Check if there is an existing settings.php file in the webroot
  stat:
    path: "{{ doc_root }}/sites/default/settings.php"
  register: php_settings

- name: Delete existing settings.php file
  file:
    path: "{{ doc_root }}/sites/default/settings.php"
    state: absent
  when: php_settings.stat.exists

- name: Write drupal settings file to tmp
  template:
    src: settings.php.j2
    dest: "/tmp/drupal_settings.php"
    owner: www-data
    group: www-data
    mode: 0644

- name: Move the drupal settings file from tmp to webroot
  command: "mv /tmp/drupal_settings.php {{ doc_root }}/sites/default/settings.php"

- name: Check if Drupal can be bootstrapped
  command: /usr/local/bin/drush status-report
  args:
    chdir: "{{ doc_root }}"
  ignore_errors: yes
  no_log: true
  register: drupal_bootstrapped

- name: Setting timestamp fact for naming purposes
  set_fact: epoch="{{ lookup('pipe','date +%Y%m%d%H%M%S') }}"
  when: restore_db_backup or restore_files_backup

- name: Checking if DB backup is already downloaded
  stat:
    path: "/tmp/{{ database_backup_name }}"
  register: drupal_db_dump

- name: Retrieve DB backup from s3
  s3:
    region: "{{ region }}"
    aws_access_key: "{{ aws_access_key }}"
    aws_secret_key: "{{ aws_secret_key }}"
    mode: get
    bucket: "{{ s3_bucket }}"
    object: "{{ database_backup_name }}"
    dest: "/tmp/{{ database_backup_name }}"
  when: (not drupal_db_dump.stat.exists) and restore_db_backup and db_backup_url is not defined

- name: Import the DB backup
  mysql_db:
    state: import
    name: "{{ drupal_mysql_database }}"
    target: "/tmp/{{ database_backup_name }}"
  when: drupal_bootstrapped.rc != 0 and restore_db_backup and db_backup_url is not defined

- name: Retrieve files backup from s3
  s3:
    region: "{{ region }}"
    aws_access_key: "{{ aws_access_key }}"
    aws_secret_key: "{{ aws_secret_key }}"
    mode: get
    bucket: "{{ s3_bucket }}"
    object: "{{ files_backup_name }}"
    dest: "/tmp/{{ files_backup_name }}"
  when: restore_files_backup

- name: Extract the files backup
  sudo: yes
  unarchive:
    src: "/tmp/{{ files_backup_name }}"
    dest: "{{ doc_root }}/sites/default"
    owner: www-data
    group: www-data
    copy: no
  when: restore_files_backup

# What if we want to restore DB from a 'public' store?
- name: Retrieve sanitised DB backup
  get_url:
    url: "{{ db_backup_url }}"
    dest: "/tmp/db_backup.sql.gz"
  when: db_backup_url is defined

# Extract DB backup
- name: Import the DB backup
  mysql_db:
    state: import
    name: "{{ drupal_mysql_database }}"
    target: "/tmp/db_backup.sql.gz"
  when: db_backup_url is defined

- name: Ensure files directory exists and is owned by www-data
  file:
    dest: "{{ doc_root }}/sites/default/files"
    state: directory
    owner: www-data
    group: www-data
    recurse: yes
    mode: 0775

- name: Ensure private files directory exists and is owned by www-data (and automatically chown new files by www-data)
  file:
    dest: "{{ doc_root }}/sites/default/private"
    state: directory
    owner: www-data
    group: www-data
    recurse: yes
    mode: 2775

- name: Run Drupal site-install
  command: "/usr/local/bin/drush site-install {{ drupal_install_profile }} --site-name={{ drupal_site_name }} -y"
  args:
    chdir: "{{ doc_root }}"
  when: drupal_bootstrapped.rc != 0 and not restore_db_backup
  tags: install
  register: drupal_site_install

- name: Enable drupal memcache module
  command: /usr/local/bin/drush en memcache -y
  args:
    chdir: "{{ doc_root }}"
  tags: install

- name: "Request updatedb-status (may fail)"
  command: "/usr/local/bin/drush -r /var/www updatedb-status -y"
  register: updatedb_status_output
  ignore_errors: yes
  tags: update

- name: Debug output of drush updatedb-status in case it failed
  debug: msg="{{ updatedb_status_output }}"
  when: updatedb_status_output|failed
  tags: update

- name: Rebuild Drupal registry in case drush updatedb-status failed
  command: "/usr/local/bin/drush -r /var/www registry-rebuild --no-cache-clear"
  when: updatedb_status_output|failed
  tags: update

- name: "Request updatedb-status (may NOT fail)"
  command: "/usr/local/bin/drush -r /var/www updatedb-status -y"
  register: updatedb_status_output
  when: updatedb_status_output|failed
  tags: update

- name: "Updating Drupal DB schema if applicable (may fail)"
  command: "/usr/local/bin/drush -r /var/www updatedb --clear-cache=0 -y"
  register: updatedb_output
  when: updatedb_status_output.stdout is defined and 'No database updates required' not in updatedb_status_output.stdout
  ignore_errors: yes
  tags: update

- name: Debug output if drush updb failed
  debug: msg="{{ updatedb_output }}"
  when: updatedb_output|failed
  tags: update

- name: Check if Drupal Features are enabled
  shell: "/usr/local/bin/drush -r /var/www pm-list | grep '(features)' | grep Enabled"
  when: drupal_site_install is not defined or drupal_site_install|skipped
  tags: update
  ignore_errors: yes
  register: drupal_enabled_features

- name: Reverting Drupal Features
  command: "/usr/local/bin/drush -r /var/www features-revert-all -y"
  when: drupal_enabled_features is defined and drupal_enabled_features|success
  tags: update

- name: Check if Drupal Set Environment is enabled
  shell: "/usr/local/bin/drush -r /var/www pm-list | grep '(set_environment)' | grep Enabled"
  when: drupal_site_install is defined and drupal_site_install|skipped
  tags: update
  ignore_errors: yes
  register: drupal_enabled_set_env

- name: Set the drupal environment
  command: /usr/local/bin/drush set-environment --force
  args:
    chdir: "{{ doc_root }}"
  when: drupal_enabled_set_env is defined and drupal_enabled_set_env|success

# Download the stage_file_proxy module (when we aren't explicitly restoring the files dump)
- name: Install the stage_file_proxy drupal module
  command: "/usr/local/bin/drush pm-download stage_file_proxy -y"
  args:
    chdir: "{{ doc_root }}"
  when: not restore_files_backup

- name: Enable the stage_file_proxy module
  command: "/usr/local/bin/drush pm-enable stage_file_proxy -y"
  args:
    chdir: "{{ doc_root }}"
  when: not restore_files_backup

## Obtain Drupal Status output, retry 3 times to try to force those errors out
#- name: Fetching Drupal Status Report
#  command: "drush status-report --format=json"
#  args:
#    chdir: "{{ doc_root }}"
#  register: status_report_command_result
#  until: (status_report_command_result.stdout | from_json).values() | selectattr('severity', 'equalto', 'Error') | selectattr('description', 'search', 'There was a problem checking available updates') | list | length == 0
#  retries: 3
#  delay: 10

#- name: Validate Drupal status report command result
#  fail: msg="Command returned a non-zero status - {{ status_report_command_result }}"
#  when: status_report_command_result.rc != 0
      
#- name: Convert Drupal status report from json
#  set_fact:
#    drupal_status_report__: "{{ status_report_command_result.stdout | from_json }}"

#- name: Find out Drupal version
#  set_fact:
#    drupal_version__: "{{ drupal_status_report__.drupal.value }}"

#- debug: 
#  msg: "Drupal version set to {{ drupal_version__ }}"

#- name: Obtain Drupal Version
#  command: "echo '{{ drupal_version__ }}'|cut -f1 -d."
#  register: drupal_version_int



- name: Obtain Drupal Status
  shell: /usr/local/bin/drush status | grep "Drupal version"
  args:
    chdir: "{{ doc_root }}"
  register: drupal_status

- name: Debug drupal_status variable
  debug: msg="{{ drupal_status }}"

- name: Obtain Drupal Version
  shell: echo "{{ drupal_status.stdout }}"|cut -d: -f2|tr ' ' ''|cut -f1 -d.
  register: drupal_version_int

- name: Debug drupal_version variable
  debug: msg="{{ drupal_version_int.stdout }}"



# Set site to use stage for assets (instead of downloading locally) for Drupal version <= v7
- name: Set the stage URL for the stage_file_proxy module
  command: "/usr/local/bin/drush variable-set stage_file_proxy_origin '{{ drupal_stage_site_url }}'"
  args:
    chdir: "{{ doc_root }}"
  when: not restore_files_backup and drupal_version_int.stdout|int <= 7

# Set site to use stage for assets (instead of downloading locally) for Drupal version >= v8
- name: Set the stage URL for the stage_file_proxy module
  command: "drush config-set stage_file_proxy.settings origin '{{ drupal_stage_site_url }}' -y"
  args:
    chdir: "{{ doc_root }}"
  when: not restore_files_backup and drupal_version_int.stdout|int >= 8

# Download and enable the devel module
- name: Install the devel drupal module
  command: "/usr/local/bin/drush pm-download devel -y"
  args:
    chdir: "{{ doc_root }}"

- name: Enable the devel module
  command: "/usr/local/bin/drush pm-enable devel -y"
  args:
    chdir: "{{ doc_root }}"
